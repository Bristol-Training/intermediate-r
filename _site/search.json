[
  {
    "objectID": "pages/020-packages.html",
    "href": "pages/020-packages.html",
    "title": "Packages",
    "section": "",
    "text": "The R community actively contributes to package development, resulting in a rapidly growing ecosystem of packages that extend the core functionality. This package ecosystem is one of its greatest strengths, providing an extensive collection of tools and functionalities that make R a powerful language for data analysis, statistics, and visualization.\nPackages can be found hosted in different repositiories on the Internet. The main ones are:\n\nCRAN (Comprehensive R Archive Network): the official repository containing thousands of packages\nBioconductor: a repository focused on bioinformatics\nGitHub: some developers host their R packages on GitHub\n\nR packages in CRAN can be easily installed using the install.packages() function. Once installed, packages are loaded into the R environment using the library() function. We are going to see examples of of how to use both functions in this section.\n\nCRAN\nThe power of R comes from its great wealth of excellent packages. These packages are managed in a central repository called CRAN (the Comprehensive R Archive Network). There are very strict protocols to follow to publish a package in CRAN, which includes an external review stage. As such, publishing an R package is a lot like publishing a paper, and so R packages on CRAN are mostly of a high standard, and come complete with documentation and tests. You can get an idea of what is needed to publish a package on CRAN by reading R Packages by Hadley Wickham and Jennifer Bryan. This excellent online book provides complete detail of how to write and publish an R package.\nA good way to find the package you want is to use an R search service, such as rseek. You can search for individual package names, or even the kind of thing you want to do. As most R packages come with vignettes (web pages that show documentation and examples of how to use the package) this means you can quickly find both the package that achieves your goal, plus documentation and examples.\n\n\n\n\n\n\nExercise\n\n\n\nUse https://rseek.org to look for packages that help you calculate Pearson’s product-moment correlation. Limit the search to vignettes. Can you find a vignette that shows you how to do this? Do not worry that the R in the vignette is more advanced than you’ve seen so far - it won’t be long before it will make sense.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nGo to https://rseek.org and search for the method we are interested in: “pearson product-moment correlation”. Set the search type to “Vignette”, and you should see several results.\nThis search result shows promise, so take a look at that: broom and dply.\nThis page contains an example showing a calculation of Pearson’s product-moment correlation. From this we can see that the cor.test from the stats package is used to calculate these correlations. We can get help with cor.test by typing ?cor.test in the console.",
    "crumbs": [
      "Packages"
    ]
  },
  {
    "objectID": "pages/031-importing-functions.html",
    "href": "pages/031-importing-functions.html",
    "title": "Importing functions",
    "section": "",
    "text": "It is likely that a lot of the R code in the vignettes you saw in the last page did not make sense to you now. Do not worry! You are new to R and are still near the beginning of your learning journey. Over the last half of this workshop we will explore some of the building blocks of R so that they will begin to make a little more sense ;-)\nA core building block of all programming languages is a function. A function is a reusable block of code that can be used over and over again in your program. A function takes inputs (called arguments), it then does something to those inputs to produce some outputs, which are returned to you.\nYou’ve already used many functions. For example,\nlibrary(stringr)\nhello &lt;- \"Hello R\"\nlength &lt;- str_length(hello)\ncat(sprintf(\"'%s' has %d characters\\n\", hello, length)) \nwill print 'Hello R' has 7 characters.\nThis code has four functions:\n\nlibrary : This function loads the library passed as the argument, e.g. library(stringr) loads the stringr library\nstr_length : This function calculates the number of characters in the string passed in as the argument, returning the number of characters. When input the value of hello (namely Hello R) it returns the number 7.\ncat : This prints its arguments to the screen, returning nothing.\nsprintf : This formats a string based on its many input arguments, returning the string that has been created.\n\n\nWriting your own functions\nYou can write your own functions in R! For example, let’s try to write a function that calculates the mean average of a list of numbers.\nAs input, the function will take a list of numbers. It should output a number which is the mean of those numbers.\nThere are many ways this function could be written. Here is a possible solution;\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n}\nWe can then use this function, to, e.g. calculate the average height of a group of people, by typing;\nperson_heights = c(1.62, 1.80, 1.56, 1.73, 1.91)\n\naverage_height &lt;- calculate_mean(person_heights)\n\ncat(sprintf(\"The average height is %.2f m\\n\", average_height))\nRunning this would print;\nThe average height is 1.72 m\n\n\nScaffolding\nTo explain how this worked, we need to look at how this function was defined. There is some scaffolding that is common to all functions. First, we define the function name. In R, this is a variable that holds the code of the function. We define this variable and assign data to it in the same way as if this was assigning a number to a numeric variable, or a string to a string variable, namely using the syntax variable &lt;- value:\n   Variable    assigned  value \n      ↓           ↓      ↓\ncalculate_average &lt;- function(...\nNext, we have the keyword function, that says that this is some data that is of type function. This means that the data will contain code. The arguments to function are the arguments you would like to use as input for your new function;\n                     keyword  arguments\n                        ↓        ↓\ncalculate_average &lt;- function(values) {\nNext, you need the body of the function. This body is the lines of code that will be run when your function is called. Just like with for loops or if statements, the body of code is contained within curly brackets\n                                  Open curly brackets\n                                      ↓\ncalculate_average &lt;- function(values) {\n    # body of the function is the\n    # lines of code within the curly brackets\n}\n↑\nClose curly brackets\nThe input(s) for the function is/are the argument(s) that are passed to function, in this case, values. Our code will loop through all of the values in values to calculate the mean average. Once we have finished, we reach the final part of the function, which is return. This is used to return the output of the function back to the caller.\n                           Input(s)\n                             ↓\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n        ↑\n     Return output\n}\nFinally, when we call the function, the arguments that pass to the function are used as the input. The output is then returned and assigned to the result variable. So, in this case;\n                Call function      with input(s)\n                        ↓             ↓  \naverage_height &lt;- calculate_mean(person_heights)\n     ↑         ↑\n  Output     assigned\ncalculate_mean is called with person_heights. The data referred to by person_heights is passed to calculate_mean and in this function is referred to as values. This data is looped over, the mean average calculated, resulting in an output that is returned at the end of the function, and assigned to the variable average_height.\n\nEXERCISE\nWrite a function, called calculate_max, that returns the largest value. Use this to find the largest height in the list of heights above.\nHint - start by using a variable called max_value and setting that equal to NA. Then use if (is.na(max_value) || value &gt; max_value) to test whether a value in values is greater. The || means “or”\nAnswer\n\n## Errors\nYour function works well, but what would happen if the wrong arguments were passed? What should we do if someone did this?\nresult &lt;- calculate_mean(c(\"cat\", \"dog\", \"horse\"))\nIf you run this now, you will see that R prints an error;\nError in total + value : non-numeric argument to binary operator\nThis isn’t very descriptive of helpful. You can control how R will behave in an error condition by using stop or warning.\nYou use stop if you want to stop the function from continuing, and to print an error message for the user. For example, we could use is.numeric to check if all of the values are numeric. If not, then we could stop;\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         if (!is.numeric(value)){\n             stop(\"Cannot calculate average of non-numeric values\")\n         }\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n}\n(note that ! means “not”)\nNow running;\nresult &lt;- calculate_mean(c(\"cat\", \"dog\", \"horse\"))\ngives the more useful error message;\nError in calculate_mean(c(\"cat\", \"dog\", \"horse\")) : \n  Cannot calculate average of non-numeric values\nHowever, what if instead of stopping, we want to calculate the average of any numeric values, and just warn the user if non-numeric values are passed? We can do this using the warning function, e.g.\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         number &lt;- as.numeric(value)\n\n         if (!is.na(number)){\n             total &lt;- total + number\n             count &lt;- count + 1\n         } else {\n             warning(\"Skipping '\", value, \n                     \"' as it is not numeric\")\n         }\n     }\n     return(total / count)\n}\nIn this case, we try to convert the value into a number using the as.numeric function. If this fails, it will return NA. We then test for NA using the is.na function, printing a warning that we are skipping this value if it isn’t a number.\n\nEXERCISE\nAdd error handling to your calculate_max function so that it warns when non-numeric values are skipped, and stops when there is no maximum value (i.e. because there are no numeric values passed).\nAnswer",
    "crumbs": [
      "Functions",
      "Importing functions"
    ]
  },
  {
    "objectID": "pages/040-tidyverse.html",
    "href": "pages/040-tidyverse.html",
    "title": "Tidyverse",
    "section": "",
    "text": "R is an old programming language that was written as a re-implementation of the even older language, S. Over the years this has meant that R has gained many different layers and methods of doing things. This has created lots of inconsistencies and cruft, with R sometimes behaving in strange and unexpected ways that can be confusing for new users, and not suited to applications in modern data science.\nThe tidyverse is a coherent collection of modern R packages that solves this problem. It is a coherent system of packages for data manipulation, exploration and visualization that share a common design philosophy. The packages were originally mostly developed by Hadley Wickham, but have been expanded by several contributers and has now developed into a thriving and highly supportive community.\nThere is lots of information about tidyverse on the web, e.g. R for Data Science (2e) is an online book by Hadley Wickham, Mine Çetinkaya-Rundel and Garrett Grolemund, that teaches the concepts of tidy data and shows how R with the tidyverse will help you create tidy data workflows. Modern R is the tidyverse, and it is strongly recommend that you use the tidyverse when you use R for data science.\n\n\n\n\n\n\nTidyverse philosophy\n\n\n\nThe goal of tydiverse is to help you create and work with tidy data. Tidy data is data where:\n\nEach variable is a column; each column is a variable.\nEach observation is a row; each row is an observation.\nEach value is a cell; each cell is a single value.\n\n\n\n\nInstalling and loading the tidyverse\nYou can install and use tidyverse by typing:\ninstall.packages(\"tidyverse\")\n\nlibrary(tidyverse)\nThis will download and then import tidyverse modules. Remember you only need to run install.packages(\"tidyverse\") once. You should see something similar to this printed:\n── Attaching core `tidyverse` packages ────────────────────────────────────────────────────────────────── `tidyverse` 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ──────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nThis shows that the nine core tidyverse modules have been loaded:\n\ndplyr https://dplyr.tidyverse.org\nforcats https://forcats.tidyverse.org\nggplot2 https://ggplot2.tidyverse.org/\nlubridate https://lubridate.tidyverse.org/\npurrr https://purrr.tidyverse.org\nreadr https://readr.tidyverse.org\nstringr https://stringr.tidyverse.org\ntibble https://tibble.tidyverse.org\ntidyr https://tidyr.tidyverse.org\n\nIt also shows that the modern dplyr::filter and dplyr::lag functions replace the older stats::filter and stats::lag functions.\n\n\n\n\n\n\nExercise\n\n\n\nInstall and load the tidyverse. Use the links above for the nine modules to find out exactly what each package provides.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFrom the links in the page, the tidyverse packages are:\n\ndplyr - provides a set of data manipulation functions arranged around a consistent grammar for data manipulation. This includes, for example, filtering, selecting, mutating and arranging data.\nforcats - provides updated and more consistent tools for handling R factors (ways of representing catagorical data).\nggplot2 - a package for creating fantastic graphs and visualisations of tidy data. It is built on the concept of a grammar for graphics, which, once understood, provides a straightforward and consistent interface for creating sophisticated graphs and plots of tidy data.\nlubridate - makes easier and more unintuitive to work with date-times.\npurrr - provides a functional programming toolkit, e.g. enabling you to perform functions on selected data within a tibble via mapping.\nreadr - provides an updated version of R’s data reading functions, bringing greater consistency and more predictable behaviour.\nstringr - provides a cohesive set of functions designed to make working with strings as easy as possible.\ntibble - provides an updated version of a data.frame, the tibble, that is more consistent and better-suited to the needs of modern data science\ntidyr - provides tools for cleaning and manipulating your data so that it becomes “tidy data”. The tidyverse is built on the concept of tidy data. Tidy data is where every column is a variable, every row is an observation and every cell has a single value. Typically, real-world data needs to be munged to become tidy, e.g. via pivoting, rectangling, nesting etc. This package provides the functions to do this efficiently.",
    "crumbs": [
      "Tidyverse"
    ]
  },
  {
    "objectID": "pages/070-worksheet.html",
    "href": "pages/070-worksheet.html",
    "title": "Worksheet",
    "section": "",
    "text": "This page contains a number of questions and exercises to give you a chance to practise what you have learned this session. You should create a new .R R file for each exercise.\n\n\n\n\n\n\nExercise 1\n\n\n\nThe first exercise is to practise searching the documentation. From the list of modules in the standard library, find one that contains a function to give the current date and time.\nFill in the ... in the snippet below.\nimport ...\n\ntime_now &lt;- ...\n\nprint(time_now.isoformat())\nThe output should be something like the following, but with today’s date and time:\n2048-08-32T10:53:15.062603\n\n\n\n\n\n\n\n\nAnswer 1\n\n\n\n\n\nThe function we can use is datetime.datetime.now(). There is an example in that module as well.\n#| filename: ex1.R\n#| eval: false\n\nimport datetime\n\ntime_now &lt;- datetime.datetime.now()\n\nprint(time_now.isoformat())\n\n\nTerminal/Command Prompt\n\nRScript ex1.R\n\n#| echo: false\nimport datetime\n\ntime_now &lt;- datetime.datetime.now()\n\nprint(time_now.isoformat())\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nWrite a function which can accept a string as an argument and return the first word in that string. To start you off, here’s skeleton of what the function should look like.\ndef first_word(l):\n    ...\n    return ...\nyou should be able to use it like:\nsentence &lt;- \"This is a collection of words\"\nword &lt;- first_word(sentence)\nprint(word)\ngiving the output:\nThis\n\n\n\n\n\n\n\n\nAnswer 2\n\n\n\n\n\n#| filename: ex2.R\n\ndef first_word(l):\n    words &lt;- l.split()\n    the_first_word &lt;- words[0]\n    return the_first_word\n\nsentence &lt;- \"This is a collection of words\"\nword &lt;- first_word(sentence)\nprint(word)\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nWrite a function called count_word_match which accepts three agruments:\n\na string which contains multiple words separated by spaces,\na string which gives the word that you want to count the occurrences of and\na boolean (True or False) which specifies whether the match should be case-sensitive.\n\ndef count_word_match(words, match, case_sensitive):\n    ...\n    return ...\nyou should be able to use it like:\ncount1 &lt;- count_word_match(\"To be or not to be\", \"to\", True)\nprint(count1)\n\ncount2 &lt;- count_word_match(\"To be or not to be\", \"to\", False)\nprint(count2)\ngiving the output:\n1\n2\n\n\n\n\n\n\n\n\nAnswer 3\n\n\n\n\n\n#| filename: ex3.R\n\ndef count_word_match(words, match, case_sensitive):\n    if not case_sensitive:\n        # Make both the words and the match a consistent case\n        words &lt;- words.casefold()\n        match &lt;- match.casefold()\n    \n    word_list &lt;- words.split()\n    \n    count &lt;- 0\n    for word in word_list:\n        if word == match:\n            count += 1\n    \n    return count\n\ncount1 &lt;- count_word_match(\"To be or not to be\", \"to\", True)\nprint(count1)\n\ncount2 &lt;- count_word_match(\"To be or not to be\", \"to\", False)\nprint(count2)\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nFor this exercise, you should write a function which can find references, like [4], in some text.\nIf the function is passed a string like:\n\"I recommend this book [1] but the other book [3] is better. Some people think that this website [10] is the best but I prefer this [7] one.\"\nit should return a list of integers like:\n[1, 3, 10, 7]\nThe function should be called find_references.\n\n\n\n\n\n\n\n\nAnswer 4\n\n\n\n\n\nThis exercise it tricker, but if you make some assumptions about the format of the input, you can make your life easier. For example, you can assume for now that every reference like [4] is surrounded by spaces. This allows str.split() to pull each one out as a “word”. You can also assume that every reference is an integer number.\n#| filename: ex4.R\n\ndef find_references(text):\n    words &lt;- text.split()\n    \n    refs &lt;- []\n    # For each word in the text\n    for word in words:\n        # if it's surrounded by square brackets\n        if word[0] == \"[\" and word[-1] == \"]\":\n            # grab the bit between the square brackets\n            reference &lt;- word[1:-1]\n            # convert it to a number\n            reference_number &lt;- int(reference)\n            refs.append(reference_number)\n    \n    return refs\n\nexample_text &lt;- \"I recommend this book [1] but the other book [3] is better. Some people think that this website [10] is the best but I prefer this [7] one.\"\n\nreferences &lt;- find_references(example_text)\n\nprint(references)\n\n\n\n\n\n\n\n\n\nExercise 5\n\n\n\nTake the function that you wrote in the last exercise and move it into a module called refs. You should then write a test file called test_refs.R containing:\nimport refs\n\ntext &lt;- \"I recommend this book [1] but the other book [3] is better. Some people think that this website [10] is the best but I prefer this [7] one.\"\n\nnumbers &lt;- refs.find_references(text)\n\nexpected &lt;- [1, 3, 10, 7]\nif numbers == expected:\n    print(\"Test passed\")\nelse:\n    print(\"Test failed:\", numbers, \"is not the same as\", expected)\nYou should make sure that the test passes when the test script is run with:\n\n\nTerminal/Command Prompt\n\nRScript test_refs.R\n\n\n\n\n\n\n\n\n\nAnswer 5\n\n\n\n\n\n#| filename: refs.R\n\ndef find_references(text):\n    words &lt;- text.split()\n    \n    refs &lt;- []\n    for word in words:\n        if word[0] == \"[\" and word[-1] == \"]\":\n            reference &lt;- word[1:-1]\n            reference_number &lt;- int(reference)\n            refs.append(reference_number)\n    \n    return refs\n#| filename: test_refs.R\n\nimport refs\n\ntext &lt;- \"I recommend this book [1] but the other book [3] is better. Some people think that this website [10] is the best but I prefer this [7] one.\"\n\nnumbers &lt;- refs.find_references(text)\n\nexpected &lt;- [1, 3, 10, 7]\nif numbers == expected:\n    print(\"Test passed\")\nelse:\n    print(\"Test failed:\", numbers, \"is not the same as\", expected)\n\n\nTerminal/Command Prompt\n\nRScript test_refs.R",
    "crumbs": [
      "Worksheet"
    ]
  },
  {
    "objectID": "pages/990-contributors.html",
    "href": "pages/990-contributors.html",
    "title": "Contributors",
    "section": "",
    "text": "This course has been developed by the Jean Golding Insitute.\nPart of these materials were originally written by Christopher Woods https://chryswoods.com/intermediate_r/.",
    "crumbs": [
      "Contributors"
    ]
  },
  {
    "objectID": "pages/043-tidyverse-exercise.html",
    "href": "pages/043-tidyverse-exercise.html",
    "title": "exercise",
    "section": "",
    "text": "TBD",
    "crumbs": [
      "Tidyverse",
      "exercise"
    ]
  },
  {
    "objectID": "pages/980-summary.html",
    "href": "pages/980-summary.html",
    "title": "Summary",
    "section": "",
    "text": "That’s all we have for this workshop. By now you should have a better understanding of how you can make your code more easily shared and reusable. In this workshow we have covered:\n\nUsing the R libraries and use their functions\nWays of bundling up your code into reusable units with functions\nMaking it possible to share your code with others by moving code into modules\nHow to produce custom errors\nHow to compactly generate lists with list comprehensions",
    "crumbs": [
      "Summary"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to this second course on R programming! This course builds upon Beginning R and delves deeper into installing and using packages, working with and write functions, and using tidyverse for data analysis. Get ready to take your R skills to the next level!\nFor the purpose of this course we will be using RStudio which provides you with a text editor and R console. Setting up instructions can be found here.\n\nIntended learning outcomes\nBy the end of this course, you will:\n\nFeel confident installing and using packages\nKnow how to write functions\nBe familiar with tydiverse ecosystem\nKnow how to read, filter and transform data files\nKnow how to generate simple plots\n\n\n\nHow to read this documentation\nIn this documentation, any time that we are seeing a small snippet of R code, we’ll see it written in a grey box like the following:\ncat(\"Hello, R\")\nIf the commands are executed by the machine we will see the output of them below enclosed on a vertical purple line:\n\ncat(\"Hello, R!\")\n\nHello, R!\n\n\nBy contrast, you will see larger pices of code as scripts with a given name, e.g. script.R, in a code block with darker header:\n\n\nscript.R\n\nname &lt;- \"Jean Golding\"\ncat(\"Hello,\", name, \"!\")\n\nWe may ask you to run a script using the Command Prompt (Windows) or Terminal (Mac and Linux). We will show you what commands to run and will look like this:\n\n\nTerminal/Command Prompt\n\nRscript script.R\n\nIn some cases we will introduce general programming concepts and structures using pseudocode, a high-level, easy-to-read syntax close to natural language. This should not be confused with R code and cannot be executed on your machine, but it is useful to describe how your code should behave. Here there is an example:\nFOR EACH sample IN my_study\n    IF (sample.value &gt; 100)\n        DO SOMETHING\n    OTHERWISE\n        DO SOMETHING ELSE\nThere are some exercices along this course, and it is important you try to answer them yourself to understand how R works. Exercises are shown in blue boxes followed by a yellow box that contains the answer of each exercise. We recommend you to try to answer each exercise yourself before looking at the solution.\n\n\n\n\n\n\nExercise\n\n\n\nThis is an exercise. You will need to click in the below box to see the answer.\n\n\n\n\n\n\n\n\nAnswer (click to open)\n\n\n\n\n\nThis is the answer.\n\n\n\nLast, we will highlight important points using green boxes like this one:\n\n\n\n\n\n\nKey points\n\n\n\nThese are important concepts and technical notes.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "answers/answer_hello_name.html",
    "href": "answers/answer_hello_name.html",
    "title": "Intermediate R",
    "section": "",
    "text": "To get input from the person running your script, you can use the function input(). And to get the length of your variable you can call len().\n#| filename: hello.R\n#| eval: false\nmy_name &lt;- input(\"Please tell me your name: \")\n\nname_length &lt;- len(my_name)\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")\n#| echo: false\nmy_name &lt;- \"Jean\"\n\nprint(\"Please tell me your name:\", my_name)\n\nname_length &lt;- len(my_name)\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")"
  },
  {
    "objectID": "answers/answer_string_methods.html",
    "href": "answers/answer_string_methods.html",
    "title": "Intermediate R",
    "section": "",
    "text": "You can split any string using the str.split function. By default it splits on spaces:\ns &lt;- \"what is your name\"\ns.split()\n\nJoin a list\nYou can join a list together by using the str.join function. Note that in front of the dot you put the string that you want to join with, and you pass the list you want to join together as an argument.\nl &lt;- [\"a\", \"b\", \"c\"]\n\"-\".join(l)\nl &lt;- [\"a\", \"b\", \"c\"]\n\":\".join(l)\nl &lt;- [\"a\", \"b\", \"c\"]\n\" \".join(l)"
  },
  {
    "objectID": "answers/answer_morse_case.html",
    "href": "answers/answer_morse_case.html",
    "title": "Intermediate R",
    "section": "",
    "text": "The function str.lower gives you back a copy of the string, but all made into lower case.\nIn our situation, the first letter is “S” and so letter.lower() will give us \"s\".\n#| filename: encode.R\n#| output: false\nletter_to_morse &lt;- {\n    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n    'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n    'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n    '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n    '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.', ' ':'/'\n}\n\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\n\nmorse &lt;- []\n\nfor letter in message:\n    letter &lt;- letter.lower()  #  ← We have added this line of code\n    morse_letter &lt;- letter_to_morse[letter]\n    morse.append(morse_letter)\n\nmorse_message &lt;- \" \".join(morse)\n\nprint(f\"Incoming message: {message}\")\nprint(f\"   Morse encoded: {morse_message}\")\n\n\nTerminal/Command Prompt\n\nRScript encode.R\n\n#| echo: false\nletter_to_morse &lt;- {\n    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n    'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n    'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n    '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n    '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.', ' ':'/'\n}\n\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\n\nmorse &lt;- []\n\nfor letter in message:\n    letter &lt;- letter.lower()  #  ← We have added this line of code\n    morse_letter &lt;- letter_to_morse[letter]\n    morse.append(morse_letter)\n\nmorse_message &lt;- \" \".join(morse)\n\nprint(f\"Incoming message: {message}\")\nprint(f\"   Morse encoded: {morse_message}\")"
  },
  {
    "objectID": "pages/030-functions.html",
    "href": "pages/030-functions.html",
    "title": "Functions",
    "section": "",
    "text": "You are likely already comfortable with calling functions such as:\n\nfree functions like print() and range()\nfunctions on objects (also called methods) like my_list.append() and my_str.split()\n\nIn this section we’re going to explore other functions and methods available as part of R’s core capabilities and in other modules. An important technical resource you probably will come across often is The R Standard Library.\n\nBuilt-in functions\nR comes with a bunch of functionality that you can use without having to explicitly enable anything. This includes things like integers, strings, lists, print()ing, file open()ing etc.\nFirst, lets have a peek at the built-in functions. There is a page describing these under the “Library Reference”, in a page called Built-in Functions. There we find the documentation for many of the functions we’ve already been using, for example print() and max().\nIt is worth, over time, becoming familiar with the various functions that are available. Some are quite useful for everyday work and some are more niche.\n\n\n\n\n\n\nExercise\n\n\n\nCopy the following code into a new script hello.R:\nmy_name &lt;- ...\n\nname_length &lt;- ...\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")\nReplace the first ... with a call to a built-in function which will read input from the person running the script. Replace the second ... with a call to a function which will give the length of the string my_name. When executed, the script should print out:\nPlease tell me your name: Jean\nHello Jean! Your name is 4 characters long\nIf you need it, you can search through the built-in functions page to find the appropriate functions.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nTo get input from the person running your script, you can use the function input(). And to get the length of your variable you can call len().\n#| filename: hello.R\n#| eval: false\nmy_name &lt;- input(\"Please tell me your name: \")\n\nname_length &lt;- len(my_name)\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")\n#| echo: false\nmy_name &lt;- \"Jean\"\n\nprint(\"Please tell me your name:\", my_name)\n\nname_length &lt;- len(my_name)\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")\n\n\n\n\n\nMethods for built-in data types\nR has a bunch of built-in data types, the details of them all are on the page called Built-in Types. That is the place to go to check what you can do with a str, an int, a list or a dict. There’s also a few other built-in types you might want to look into in the future such as complex, set and tuple.\nThese types being built-in means that you don’t need to explicitly enable their use and most have core-language syntax to create them.\nFor example, the code\nanimal &lt;- \"horse\"\ncreates a variable called animal from the string literal \"horse\" which is of the type str. This data type is built into the language and so the functionality that it has is documented on built-in type str.\nThis means that when we do:\nanimal.capitalize()\nit is looking at the data type of the variable animal, seeing that it is a str and then using the capitalize function that’s available for that type to do the work.\n\n\n\n\n\n\nExercise\n\n\n\nHave a look at the documentation page for the functions that you can call on strings.\nExperiment with one or two and see if you can understand the documentation. Start by trying to answer the following:\n\nGiven a string like s &lt;- \"what is your name\", find a function which can split s into a list like [\"what\", \"is\", \"your\", \"name\"]\nGiven a list like [\"a\", \"b\", \"c\"], find a function which can join it together into a string like \"a-b-c\"\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYou can split any string using the str.split function. By default it splits on spaces:\ns &lt;- \"what is your name\"\ns.split()\n\nJoin a list\nYou can join a list together by using the str.join function. Note that in front of the dot you put the string that you want to join with, and you pass the list you want to join together as an argument.\nl &lt;- [\"a\", \"b\", \"c\"]\n\"-\".join(l)\nl &lt;- [\"a\", \"b\", \"c\"]\n\":\".join(l)\nl &lt;- [\"a\", \"b\", \"c\"]\n\" \".join(l)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nChange the message in encode.R to use both upper and lower case letters:\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\nWhen you now run the script with RScript encode.R you will find that it gives you a KeyError. This is because it is looking for an upper case “S” in the dictionary letter_to_morse and not finding one (dictionary keys are case-sensitive).\nRead through the documentation for the string methods to find one that might help convert the letter you have into one that matches the keys in the dictionary. You should be able to add a single line of code in the loop straight after for letter in message:.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe function str.lower gives you back a copy of the string, but all made into lower case.\nIn our situation, the first letter is “S” and so letter.lower() will give us \"s\".\n#| filename: encode.R\n#| output: false\nletter_to_morse &lt;- {\n    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n    'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n    'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n    '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n    '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.', ' ':'/'\n}\n\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\n\nmorse &lt;- []\n\nfor letter in message:\n    letter &lt;- letter.lower()  #  ← We have added this line of code\n    morse_letter &lt;- letter_to_morse[letter]\n    morse.append(morse_letter)\n\nmorse_message &lt;- \" \".join(morse)\n\nprint(f\"Incoming message: {message}\")\nprint(f\"   Morse encoded: {morse_message}\")\n\n\nTerminal/Command Prompt\n\nRScript encode.R\n\n#| echo: false\nletter_to_morse &lt;- {\n    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n    'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n    'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n    '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n    '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.', ' ':'/'\n}\n\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\n\nmorse &lt;- []\n\nfor letter in message:\n    letter &lt;- letter.lower()  #  ← We have added this line of code\n    morse_letter &lt;- letter_to_morse[letter]\n    morse.append(morse_letter)\n\nmorse_message &lt;- \" \".join(morse)\n\nprint(f\"Incoming message: {message}\")\nprint(f\"   Morse encoded: {morse_message}\")",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "pages/032-writing-functions.html",
    "href": "pages/032-writing-functions.html",
    "title": "Writing functions",
    "section": "",
    "text": "Functions provide a way of packaging code into reusable and easy-to-use components. We saw plenty of examples of functions in the last chapter, e.g. print() wraps up all the logic about exactly how to print things, all you need to do is pass in some arguments and it handles the rest. Likewise with math.sqrt(), you don’t need to understand the algorithm it uses, simply what it needs you to pass it, and what it returns back to you.\nYou can also bundle up your own logic into functions, allowing you to avoid repeating yourself and make your code easier to read. To explain how they work, lets imagine we are writing some code to help us with baking recipes. Often you will need to convert between different units, for example from ounces to grams. Create a new script convert.R with the below code and run it.\n\nWriting your own functions\nYou can write your own functions in R! For example, let’s try to write a function that calculates the mean average of a list of numbers.\nAs input, the function will take a list of numbers. It should output a number which is the mean of those numbers.\nThere are many ways this function could be written. Here is a possible solution;\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n}\nWe can then use this function, to, e.g. calculate the average height of a group of people, by typing;\nperson_heights = c(1.62, 1.80, 1.56, 1.73, 1.91)\n\naverage_height &lt;- calculate_mean(person_heights)\n\ncat(sprintf(\"The average height is %.2f m\\n\", average_height))\nRunning this would print;\nThe average height is 1.72 m\n\n\nScaffolding\nTo explain how this worked, we need to look at how this function was defined. There is some scaffolding that is common to all functions. First, we define the function name. In R, this is a variable that holds the code of the function. We define this variable and assign data to it in the same way as if this was assigning a number to a numeric variable, or a string to a string variable, namely using the syntax variable &lt;- value:\n   Variable    assigned  value \n      ↓           ↓      ↓\ncalculate_average &lt;- function(...\nNext, we have the keyword function, that says that this is some data that is of type function. This means that the data will contain code. The arguments to function are the arguments you would like to use as input for your new function;\n                     keyword  arguments\n                        ↓        ↓\ncalculate_average &lt;- function(values) {\nNext, you need the body of the function. This body is the lines of code that will be run when your function is called. Just like with for loops or if statements, the body of code is contained within curly brackets\n                                  Open curly brackets\n                                      ↓\ncalculate_average &lt;- function(values) {\n    # body of the function is the\n    # lines of code within the curly brackets\n}\n↑\nClose curly brackets\nThe input(s) for the function is/are the argument(s) that are passed to function, in this case, values. Our code will loop through all of the values in values to calculate the mean average. Once we have finished, we reach the final part of the function, which is return. This is used to return the output of the function back to the caller.\n                           Input(s)\n                             ↓\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n        ↑\n     Return output\n}\nFinally, when we call the function, the arguments that pass to the function are used as the input. The output is then returned and assigned to the result variable. So, in this case;\n                Call function      with input(s)\n                        ↓             ↓  \naverage_height &lt;- calculate_mean(person_heights)\n     ↑         ↑\n  Output     assigned\ncalculate_mean is called with person_heights. The data referred to by person_heights is passed to calculate_mean and in this function is referred to as values. This data is looped over, the mean average calculated, resulting in an output that is returned at the end of the function, and assigned to the variable average_height.\n\nEXERCISE\nWrite a function, called calculate_max, that returns the largest value. Use this to find the largest height in the list of heights above.\nHint - start by using a variable called max_value and setting that equal to NA. Then use if (is.na(max_value) || value &gt; max_value) to test whether a value in values is greater. The || means “or”\nAnswer\n\n## Errors\nYour function works well, but what would happen if the wrong arguments were passed? What should we do if someone did this?\nresult &lt;- calculate_mean(c(\"cat\", \"dog\", \"horse\"))\nIf you run this now, you will see that R prints an error;\nError in total + value : non-numeric argument to binary operator\nThis isn’t very descriptive of helpful. You can control how R will behave in an error condition by using stop or warning.\nYou use stop if you want to stop the function from continuing, and to print an error message for the user. For example, we could use is.numeric to check if all of the values are numeric. If not, then we could stop;\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         if (!is.numeric(value)){\n             stop(\"Cannot calculate average of non-numeric values\")\n         }\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n}\n(note that ! means “not”)\nNow running;\nresult &lt;- calculate_mean(c(\"cat\", \"dog\", \"horse\"))\ngives the more useful error message;\nError in calculate_mean(c(\"cat\", \"dog\", \"horse\")) : \n  Cannot calculate average of non-numeric values\nHowever, what if instead of stopping, we want to calculate the average of any numeric values, and just warn the user if non-numeric values are passed? We can do this using the warning function, e.g.\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         number &lt;- as.numeric(value)\n\n         if (!is.na(number)){\n             total &lt;- total + number\n             count &lt;- count + 1\n         } else {\n             warning(\"Skipping '\", value, \n                     \"' as it is not numeric\")\n         }\n     }\n     return(total / count)\n}\nIn this case, we try to convert the value into a number using the as.numeric function. If this fails, it will return NA. We then test for NA using the is.na function, printing a warning that we are skipping this value if it isn’t a number.\n\nEXERCISE\nAdd error handling to your calculate_max function so that it warns when non-numeric values are skipped, and stops when there is no maximum value (i.e. because there are no numeric values passed).\nAnswer",
    "crumbs": [
      "Functions",
      "Writing functions"
    ]
  },
  {
    "objectID": "pages/042-tidyverse-pipe.html",
    "href": "pages/042-tidyverse-pipe.html",
    "title": "Pipes %>%",
    "section": "",
    "text": "The tidyverse makes heavy use of the R concept of forward pipes. Forward pipes, represented via %&gt;%, are provided by the magrittr package, which should be automatically loaded by the tidyverse.\nA forward pipe forwards the variable on the left into the first argument to the function on the right, e.g.\n\"kitten\" %&gt;% print()\nwill forward the string “kitten” so that it is the first argument to the function print. Hence this is exactly identical to\nprint(\"kitten\")\nYou may ask why this is useful? It is useful because it enables you to chain together a lot of functions. For example, the tidyverse dply package provides the function filter, for filtering data.\nSo;\ncats %&gt;% filter(Sex==\"F\")\n# A tibble: 47 x 3\n   Sex   BodyWeight HeartWeight\n   &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1 F            2           7  \n 2 F            2           7.4\n 3 F            2           9.5\n 4 F            2.1         7.2\n 5 F            2.1         7.3\n 6 F            2.1         7.6\n 7 F            2.1         8.1\n 8 F            2.1         8.2\n 9 F            2.1         8.3\n10 F            2.1         8.5\n# … with 37 more rows\nhas filtered the cats data set from the last page to return a tibble that contains data only for female cats.\nThis was identical to typing;\nfilter(cats, Sex==\"F\")\nThe power comes that we can now chain filters, e.g.\ncats %&gt;% filter(Sex==\"F\") %&gt;% filter(BodyWeight &gt; 2.5)\n# A tibble: 11 x 3\n   Sex   BodyWeight HeartWeight\n   &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1 F            2.6         8.7\n 2 F            2.6        10.1\n 3 F            2.6        10.1\n 4 F            2.7         8.5\n 5 F            2.7        10.2\n 6 F            2.7        10.8\n 7 F            2.9         9.9\n 8 F            2.9        10.1\n 9 F            2.9        10.1\n10 F            3          10.6\n11 F            3          13  \nWe can then use the dplyr summarise function to call calculate_mean on a specified row of this filtered data, e.g.\ncats %&gt;% \n    filter(Sex==\"F\") %&gt;% \n    filter(BodyWeight&gt;2.5) %&gt;% \n    summarise(mean=calculate_mean(HeartWeight))\nwill output\n# A tibble: 1 x 1\n   mean\n  &lt;dbl&gt;\n1  10.2\nas the mean average of the heart weight in grams of female cats whose body weight is greater than 2.5 kg.\nNote how we have split this over multiple lines, putting the forward pipe %&gt;% at the end so that it is clear that the line continues (use Shift+Enter to start a new line without running the command in the R Console).\nTo save this to a variable, we would use the assign &lt;- as normal, hence the full code should be;\naverage_heart_weight &lt;- cats %&gt;%\n    filter(Sex==\"F\") %&gt;%\n    filter(BodyWeight&gt;2.5) %&gt;%\n    summarise(mean=calculate_mean(HeartWeight))\nYes, this is a very dense bit of code. This is typical for R. You will often see very dense blocks of code that use forward pipes to push data through several functions, resulting in a final output result. As you can see, it is important that you name your variables, data, columns and functions clearly, so that it is easier for future readers of your code to understand what is going on.\nFinally, note that average_heart_weight is a 1x1 tibble. You can extract the actual numeric value by typing as.numeric(average_heart_weight).\n\nEXERCISE\nCalculate the average heart weight of male cats whose body weight is greater than or equal to 3.0 kg.\nAnswer\nCalculate the maximum body weight of both the male cat and the female cat that has a heart weight of less than or equal to 9 grams.\nAnswer\nLook back at the vignette you found when searching for the Pearson’s product-moment correlation. How much more of this vignette do you now understand? Have a go at installing packages that you don’t recognise, and using ? in RStudio to get help on the functions that are new to you.",
    "crumbs": [
      "Tidyverse",
      "Pipes %>%"
    ]
  },
  {
    "objectID": "pages/041-tidyverse-tibbles.html",
    "href": "pages/041-tidyverse-tibbles.html",
    "title": "Tibbles",
    "section": "",
    "text": "Recap dataframes\n\n\nTibbles and readr\nA tibble is the modern tidyverse version of a data.frame. A tibble is a data.frame, and so can be used in the same way. But it comes with more powerful features and removes inconsistent and confusing behaviour.\nIn the same way, readr provides modern tidyverse replacements for R’s standard reading functions. readr provides read_csv, which is a better way of reading csv files than R’s standard read.csv.\nLet’s now use the tidyverse to read_csv the cats data set into a tibble.\ncats &lt;- read_csv(\"https://bristol-training.github.io/intermediate-r/data/cats.csv\")\nThe first thing you will notice is that the tidyverse has printed out some useful information:\nParsed with column specification:\ncols(\n  Sex = col_character(),\n  BodyWeight = col_double(),\n  HeartWeight = col_double()\n)\nThis is telling you that read_csv found three columns; Sex, which is treated as a columns of strings (characters), and BodyWeight and HeartWeight, which are both treated as columns of floating point numbers (doubles).\nNext, if you type cats and press return you will see\ncats$Bodyweight\n# A tibble: 144 x 3\n   Sex   BodyWeight HeartWeight\n   &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1 F            2           7  \n 2 F            2           7.4\n 3 F            2           9.5\n 4 F            2.1         7.2\n 5 F            2.1         7.3\n 6 F            2.1         7.6\n 7 F            2.1         8.1\n 8 F            2.1         8.2\n 9 F            2.1         8.3\n10 F            2.1         8.5\n# … with 134 more rows\nYou can see that the tibble summarises itself to the screen. This makes it much easier to quickly look at some data without it overflowing your console.\nAs a tibble is a data.frame, you can use the same methods of accessing data, e.g.\ncats$Bodyweight\n[1] 2.0 2.0 2.0 2.1 2.1 2.1 2.1 2.1 2.1 2.1 2.1 2.1 2.2\n [14] 2.2 2.2 2.2 2.2 2.2 2.3 2.3 2.3 2.3 2.3 2.3 2.3 2.3\n [27] 2.3 2.3 2.3 2.3 2.4 2.4 2.4 2.4 2.5 2.5 2.6 2.6 2.6\n [40] 2.7 2.7 2.7 2.9 2.9 2.9 3.0 3.0 2.0 2.0 2.1 2.2 2.2\n [53] 2.2 2.2 2.2 2.2 2.2 2.2 2.3 2.4 2.4 2.4 2.4 2.4 2.5\n [66] 2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.6 2.6 2.6 2.6 2.6 2.6\n [79] 2.7 2.7 2.7 2.7 2.7 2.7 2.7 2.7 2.7 2.8 2.8 2.8 2.8\n [92] 2.8 2.8 2.8 2.9 2.9 2.9 2.9 2.9 3.0 3.0 3.0 3.0 3.0\n[105] 3.0 3.0 3.0 3.0 3.1 3.1 3.1 3.1 3.1 3.1 3.2 3.2 3.2\n[118] 3.2 3.2 3.2 3.3 3.3 3.3 3.3 3.3 3.4 3.4 3.4 3.4 3.4\n[131] 3.5 3.5 3.5 3.5 3.5 3.6 3.6 3.6 3.6 3.7 3.8 3.8 3.9\n[144] 3.9\ncats[1,]\n# A tibble: 1 x 3\n  Sex   BodyWeight HeartWeight\n  &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n1 F              2           7\netc.\n\nEXERCISE\nLoad the cats data set into a tibble using read_csv. Use the calculate_mean and calculate_max functions from before to calculate the mean and max body weight and heart weight of the cats.\nWhat are the units for the weights? A description of the data set can be found here.\nAnswer",
    "crumbs": [
      "Tidyverse",
      "Tibbles"
    ]
  },
  {
    "objectID": "pages/010-workspace-setup.html",
    "href": "pages/010-workspace-setup.html",
    "title": "Workspace setup",
    "section": "",
    "text": "There are lots of different ways to run R code and many tools to help you write it. You don’t require any special tools to create an R script, a simple text editor like Notepad on Windows is sufficient. More advanced tools include IDEs like RStudio or Visual Studio Code.\nFor this workshop we will be keeping things as simple as possible in order to allow us to focus on the topics we’re learning without having to learn too many extra tools along the way.\nFor the purpose of this course we will be using a free tool called RStudio which provides you with an integrated enviroment where you can write and run R code. The easiest way to get access to R and RStudio is first downloading and installing the latest R version from https://cran.rstudio.com/, and after downloading and installing RStudio from https://posit.co/download/rstudio-desktop/. You may need administrator access to install R and RStudio on your computer. Both tools are freely available for Windows, MacOS and Linux.\n\n\n\n\n\n\nInstallation on University managed computers\n\n\n\nIf you are using a University of Bristol computer, you will find R and RStudio in Company Portal.\n\n\nOnce both are installed, you can open RStudio and will look something like this:\n\nThe way that we will be setting up the space is to have a text editor on the top-left side of the screen and the R console on the bottom-left side. We’ll use the editor to write our code and the console to run it. On the right side we can keep other tabs open.\n\nWorking directory\nSetting up a working directory helps organize your project files and ensures that your code can find any necessary resources and dependencies. We will revisit this concept later on, but for now be mindful that the space where you save your scripts has to be the same than the working directory where R console and/or your Command Prompt/Terminal are working,\nIn R Console you can print the current working directory it with\ngetwd()\n\n\n[1] \"/Users/ab12345\"\n\n\nAlternatively, if you are using the Command Prompt (Windows) you can check your current directory with\n\n\nCommand Prompt\n\ncd\n\nOr if you are using a Terminal (MacOS and Linux) you can check your current directory with\n\n\nTerminal\n\npwd\n\nWe’re now ready to get started!",
    "crumbs": [
      "Workspace setup"
    ]
  },
  {
    "objectID": "pages/022-loading-packages.html",
    "href": "pages/022-loading-packages.html",
    "title": "Loading packages",
    "section": "",
    "text": "Using a package\nYou can use a package in your script via the library command. To use stringr you should type;\nlibrary(stringr)\ninto the console. When you press return, nothing should happen. If you see output similar to;\nError in library(stringr) : there is no package called ‘stringr’\nthen this means that stringr is not installed properly.\nTo get help on a package type ? before its name, e.g.\n?stringr\nAll of the functions in stringr start with str_ and take a string (or vector/list of strings) as the first argument.\nKey functions are;\n\nstr_c : Modern replacement for cat\nstr_length : Count the number of characters in a string\nstr_sub : Extract substrings\nstr_trim : Remove trailing and leading whitespace\nstr_pad : Pad a string\nstr_wrap : Wrap a string into a paragraph\n\n\nEXERCISE\nUse ? to learn about the above stringr functions and have a play printing different strings to the console.\nAnswer",
    "crumbs": [
      "Packages",
      "Loading packages"
    ]
  },
  {
    "objectID": "pages/021-install-packages.html",
    "href": "pages/021-install-packages.html",
    "title": "Installing CRAN packages",
    "section": "",
    "text": "CRAN packages can be easily installed using the install.packages function. For example, the stringr package provides a set of modern functions for manipulating and formatting strings.\nTo use stringr, we first need to install the package typing into your script or console:\ninstall.packages(\"stringr\")\nand click run or hit return, respectively. If your user account has permission to install packages then you should see something like:\ntrying URL 'https://cloud.r-project.org/bin/macosx/big-sur-arm64/contrib/4.4/stringr_1.5.1.tgz'\nContent type 'application/x-gzip' length 314273 bytes (306 KB)\n==================================================\ndownloaded 306 KB\n\nThe downloaded binary packages are in\n    /var/folders/bq/2w1p57q54r78thfjpfy2cbrc0000gp/T//RtmpQ8lR4N/downloaded_packages\nNotice that this will automatically get the right package for your operating system (in this example macosx). Also note that you only have to do this once, as once installed, this package is already available. If you have permission issues installing new packages in your system, you can try installing them in your user space with\ninstall.packages(\"stringr\", lib=\"/Users/ab12345/rlib\")\nwhere /Users/ab12345/rlib is a folder in your user space; or contact your IT service for help.\n\nUpdating packages\nR package management is handled directly within the language, what makes makes easier to install packages and keep them up to date.\nTo update a package you can simply run install.packages again, e.g. to update stringr to the newest version, just type:\ninstall.packages(\"stringr\")\nYou can get a list of all installed packages via installed.packages(), e.g.\n\n# note that we are printing only a few of them\ninstalled.packages()[10:30]\n\n [1] \"bslib\"      \"cachem\"     \"callr\"      \"cellranger\" \"class\"     \n [6] \"cli\"        \"clipr\"      \"cluster\"    \"codetools\"  \"colorspace\"\n[11] \"compiler\"   \"conflicted\" \"cpp11\"      \"crayon\"     \"curl\"      \n[16] \"data.table\" \"datasets\"   \"DBI\"        \"dbplyr\"     \"digest\"    \n[21] \"dplyr\"     \n\n\nYou can get a list of all packages for which new versions are available using old.packages(), e.g.\nold.packages()\n\n\n           Installed  Built   ReposVer  Repository                            \nboot       \"1.3-30\"   \"4.4.0\" \"1.3-31\"  \"https://cran.rstudio.com/src/contrib\"\nforeign    \"0.8-86\"   \"4.4.0\" \"0.8-87\"  \"https://cran.rstudio.com/src/contrib\"\nglue       \"1.7.0\"    \"4.4.0\" \"1.8.0\"   \"https://cran.rstudio.com/src/contrib\"\nKernSmooth \"2.23-22\"  \"4.4.0\" \"2.23-24\" \"https://cran.rstudio.com/src/contrib\"\nMASS       \"7.3-60.2\" \"4.4.0\" \"7.3-61\"  \"https://cran.rstudio.com/src/contrib\"\nMatrix     \"1.7-0\"    \"4.4.0\" \"1.7-1\"   \"https://cran.rstudio.com/src/contrib\"\nnlme       \"3.1-164\"  \"4.4.0\" \"3.1-166\" \"https://cran.rstudio.com/src/contrib\"\nsurvival   \"3.5-8\"    \"4.4.0\" \"3.7-0\"   \"https://cran.rstudio.com/src/contrib\"\n\n\nYou can update all packages for which updates are available using update.packages(). You can add the option update.packages(ask=FALSE) to update everything without prompting. Note that updating all of your packages could take a while if you haven’t done it recently.\nupdate.packages()\n\n\nboot :\n Version 1.3-30 installed in /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library \n Version 1.3-31 available at https://cran.rstudio.com\nUpdate? (Yes/no/cancel)\n\n\n\n\n\n\n\n\nUpdates and reproducibility\n\n\n\nSoftware updates can pose challenges for reproducibility. It’s important to document and track the specific versions of software and packages used. renv is a package management tool for R that helps create reproducible environments.",
    "crumbs": [
      "Packages",
      "Installing CRAN packages"
    ]
  }
]