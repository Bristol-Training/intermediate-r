[
  {
    "objectID": "pages/020-packages.html",
    "href": "pages/020-packages.html",
    "title": "Packages",
    "section": "",
    "text": "While there are a good number of built-in functions and types, and you can go a long way without needing anything more, they are ultimately limited. Luckily, R has a “batteries included” philosophy and provides a lot of additional functionality which can be explored in The R Standard Library.\nThe functionality provided by the Standard Library is provided in a series of modules, each of which serves a particular purpose. The modules in the Standard Library are always installed in any version of R you have. Note that even though they are always accessible, they do not count as “built-in” as in R terms, that means something which you can use without having to access any extra modules.\n\nThe math module\nLet’s start by looking at one of the modules, the “math — Mathematical functions” module. This module provides a bunch of mathematical tools such as averages, trigonometry etc.\nYou can get access to the module by importing it by name:\nimport math\nOnce it is imported, you can use any of the functions inside it by typing the name of the module, followed by a dot, followed by the name of the function. So to call the square root function you would do:\n#| filename: imports.R\nimport math\n\nprint(math.sqrt(25))\nYou can think of this as saying “from the math module that I’ve just imported, get the sqrt function and call it”.\nAlternatively, if you want to grab a specific function out of a module so that you can call it without specifying the module name, you can do:\n#| filename: imports.R\nfrom math import sqrt\n\nprint(sqrt(25))\nNote that we have seen two examples of places where dot . is used when calling functions in R:\n\ncalling a method on a variable like with my_list.append() or my_string.split(),\ncalling a function from an imported module like math.sqrt().\n\nIn both these cases the dot is doing a very similar job. It’s saying “look inside the thing on the left of the dot for a thing called …”. In some cases, it’s looking inside a data type, and in other it’s looking inside a module.\n\n\n\n\n\n\nExercise\n\n\n\nWe saw earlier how to check our current working directory in the Command Prompt/Terminal using cd (Windows) and pwd (MacOS and Linux). Using the The R Standard Library, find a function that returns the working directory in R.\n\n\nIt is worth, over time, becoming familiar with the various functions that are available. Some are quite useful for everyday work and some are more niche.\nThe string formatting in R can feel old fashioned because R is an old programming language. R was created in 1995 to be a better version of an even older programming language called S, which was created in 1976. The clunkiness of parts of R when compared to modern languages is due to this heritage.\nFortunately, R is not stuck in the past. R comes with a lot of packages that extend the core functionality, and provide a more modern interface to its most powerful functionality. When we use R with these packages, we are using “modern R”.\nFor example, the Stringr package provides a set of modern functions for manipulating and formatting strings.\nTo use Stringr, we first need to install the package. You install packages in R using install.packages, e.g. type into your console;\ninstall.packages(\"stringr\")\nand hit return. If your user account has permission to install packages then you should see something like;\ntrying URL 'https://cran.rstudio.com/bin/macosx/contrib/4.0/stringr_1.4.0.tgz'\nContent type 'application/x-gzip' length 210650 bytes (205 KB)\n==================================================\ndownloaded 205 KB\n\n\nThe downloaded binary packages are in\n    /var/folders/vg/lyxsq9391fxfm64hfdfr88f40000gq/T//Rtmp57uUY0/downloaded_packages\nNotice that this will automatically get the right package for your operating system (in my case macosx). Also note that you only have to do this once, as once installed, this package is available for everyone.\n\n\nUsing a package\nYou can use a package in your script via the library command. To use stringr you should type;\nlibrary(stringr)\ninto the console. When you press return, nothing should happen. If you see output similar to;\nError in library(stringr) : there is no package called ‘stringr’\nthen this means that stringr is not installed properly.\nTo get help on a package type ? before its name, e.g.\n?stringr\nAll of the functions in stringr start with str_ and take a string (or vector/list of strings) as the first argument.\nKey functions are;\n\nstr_c : Modern replacement for cat\nstr_length : Count the number of characters in a string\nstr_sub : Extract substrings\nstr_trim : Remove trailing and leading whitespace\nstr_pad : Pad a string\nstr_wrap : Wrap a string into a paragraph\n\n\nEXERCISE\nUse ? to learn about the above stringr functions and have a play printing different strings to the console.\nAnswer\n\n\n\nCRAN\nThe power of R comes from its great wealth of excellent packages. These packages are managed in a central repository called CRAN (the Comprehensive R Archive Network). There are very strict protocols to follow to publish a package in CRAN, which includes an external review stage. As such, publishing an R package is a lot like publishing a paper, and so R packages on CRAN are mostly of a high standard, and come complete with documentation and tests. You can get an idea of what is needed to publish a package on CRAN by reading R Packages by Hadley Wickham and Jennifer Bryan. This excellent online book provides complete detail of how to write and publish an R package.\nA good way to find the package you want is to use an R search service, such as rseek. You can search for individual package names, or even the kind of thing you want to do. As most R packages come with vignettes (web pages that show examples of how to use the package) this means you can quickly find both the package that achieves your goal, plus really clear documentation and examples.\n\nEXERCISE\nUse rseek to look for packages that help you calculate Pearson’s product-moment correlation. Limit the search to vignettes. Can you find a vignette that shows you how to do this? Do not worry that the R in the vignette is more advanced than you’ve seen so far - it won’t be long before it will make sense ;-)\nAnswer\n\n\n\nUpdating packages\nR’s strength is its packages, and what makes this easier is that package management is handled directly within the language.\nYou can update a package by running install.packages again, e.g. to update stringr to the newest version, just type;\ninstall.packages(\"stringr\")\nYou can get a list of all installed packages via installed.packages(), e.g.\ninstalled.packages()\nYou can get a list of all packages for which new versions are available using old.packages(), e.g.\nold.packages()\nYou can update all packages for which updates are available using update.packages(). Set ask=FALSE to update everything without prompting, e.g.\nupdate.packages(ask=FALSE)\nNote that updating all of your packages could take a while if you haven’t done it recently…",
    "crumbs": [
      "Packages"
    ]
  },
  {
    "objectID": "pages/031-importing-functions.html",
    "href": "pages/031-importing-functions.html",
    "title": "Importing functions",
    "section": "",
    "text": "It is likely that a lot of the R code in the vignettes you saw in the last page did not make sense to you now. Do not worry! You are new to R and are still near the beginning of your learning journey. Over the last half of this workshop we will explore some of the building blocks of R so that they will begin to make a little more sense ;-)\nA core building block of all programming languages is a function. A function is a reusable block of code that can be used over and over again in your program. A function takes inputs (called arguments), it then does something to those inputs to produce some outputs, which are returned to you.\nYou’ve already used many functions. For example,\nlibrary(stringr)\nhello &lt;- \"Hello R\"\nlength &lt;- str_length(hello)\ncat(sprintf(\"'%s' has %d characters\\n\", hello, length)) \nwill print 'Hello R' has 7 characters.\nThis code has four functions:\n\nlibrary : This function loads the library passed as the argument, e.g. library(stringr) loads the stringr library\nstr_length : This function calculates the number of characters in the string passed in as the argument, returning the number of characters. When input the value of hello (namely Hello R) it returns the number 7.\ncat : This prints its arguments to the screen, returning nothing.\nsprintf : This formats a string based on its many input arguments, returning the string that has been created.\n\n\nWriting your own functions\nYou can write your own functions in R! For example, let’s try to write a function that calculates the mean average of a list of numbers.\nAs input, the function will take a list of numbers. It should output a number which is the mean of those numbers.\nThere are many ways this function could be written. Here is a possible solution;\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n}\nWe can then use this function, to, e.g. calculate the average height of a group of people, by typing;\nperson_heights = c(1.62, 1.80, 1.56, 1.73, 1.91)\n\naverage_height &lt;- calculate_mean(person_heights)\n\ncat(sprintf(\"The average height is %.2f m\\n\", average_height))\nRunning this would print;\nThe average height is 1.72 m\n\n\nScaffolding\nTo explain how this worked, we need to look at how this function was defined. There is some scaffolding that is common to all functions. First, we define the function name. In R, this is a variable that holds the code of the function. We define this variable and assign data to it in the same way as if this was assigning a number to a numeric variable, or a string to a string variable, namely using the syntax variable &lt;- value:\n   Variable    assigned  value \n      ↓           ↓      ↓\ncalculate_average &lt;- function(...\nNext, we have the keyword function, that says that this is some data that is of type function. This means that the data will contain code. The arguments to function are the arguments you would like to use as input for your new function;\n                     keyword  arguments\n                        ↓        ↓\ncalculate_average &lt;- function(values) {\nNext, you need the body of the function. This body is the lines of code that will be run when your function is called. Just like with for loops or if statements, the body of code is contained within curly brackets\n                                  Open curly brackets\n                                      ↓\ncalculate_average &lt;- function(values) {\n    # body of the function is the\n    # lines of code within the curly brackets\n}\n↑\nClose curly brackets\nThe input(s) for the function is/are the argument(s) that are passed to function, in this case, values. Our code will loop through all of the values in values to calculate the mean average. Once we have finished, we reach the final part of the function, which is return. This is used to return the output of the function back to the caller.\n                           Input(s)\n                             ↓\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n        ↑\n     Return output\n}\nFinally, when we call the function, the arguments that pass to the function are used as the input. The output is then returned and assigned to the result variable. So, in this case;\n                Call function      with input(s)\n                        ↓             ↓  \naverage_height &lt;- calculate_mean(person_heights)\n     ↑         ↑\n  Output     assigned\ncalculate_mean is called with person_heights. The data referred to by person_heights is passed to calculate_mean and in this function is referred to as values. This data is looped over, the mean average calculated, resulting in an output that is returned at the end of the function, and assigned to the variable average_height.\n\nEXERCISE\nWrite a function, called calculate_max, that returns the largest value. Use this to find the largest height in the list of heights above.\nHint - start by using a variable called max_value and setting that equal to NA. Then use if (is.na(max_value) || value &gt; max_value) to test whether a value in values is greater. The || means “or”\nAnswer\n\n## Errors\nYour function works well, but what would happen if the wrong arguments were passed? What should we do if someone did this?\nresult &lt;- calculate_mean(c(\"cat\", \"dog\", \"horse\"))\nIf you run this now, you will see that R prints an error;\nError in total + value : non-numeric argument to binary operator\nThis isn’t very descriptive of helpful. You can control how R will behave in an error condition by using stop or warning.\nYou use stop if you want to stop the function from continuing, and to print an error message for the user. For example, we could use is.numeric to check if all of the values are numeric. If not, then we could stop;\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         if (!is.numeric(value)){\n             stop(\"Cannot calculate average of non-numeric values\")\n         }\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n}\n(note that ! means “not”)\nNow running;\nresult &lt;- calculate_mean(c(\"cat\", \"dog\", \"horse\"))\ngives the more useful error message;\nError in calculate_mean(c(\"cat\", \"dog\", \"horse\")) : \n  Cannot calculate average of non-numeric values\nHowever, what if instead of stopping, we want to calculate the average of any numeric values, and just warn the user if non-numeric values are passed? We can do this using the warning function, e.g.\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         number &lt;- as.numeric(value)\n\n         if (!is.na(number)){\n             total &lt;- total + number\n             count &lt;- count + 1\n         } else {\n             warning(\"Skipping '\", value, \n                     \"' as it is not numeric\")\n         }\n     }\n     return(total / count)\n}\nIn this case, we try to convert the value into a number using the as.numeric function. If this fails, it will return NA. We then test for NA using the is.na function, printing a warning that we are skipping this value if it isn’t a number.\n\nEXERCISE\nAdd error handling to your calculate_max function so that it warns when non-numeric values are skipped, and stops when there is no maximum value (i.e. because there are no numeric values passed).\nAnswer",
    "crumbs": [
      "Functions",
      "Importing functions"
    ]
  },
  {
    "objectID": "pages/040-tidyverse.html",
    "href": "pages/040-tidyverse.html",
    "title": "Tidyverse",
    "section": "",
    "text": "As mentioned before, R is an old programming language that was written as a re-implementation of the even older language, S. Over the years this has meant that R has gained many different layers and methods of doing things. This has created lots of inconsistencies and cruft, with R sometimes behaving in strange and unexpected ways that can be confusing for new users, and not suited to applications in modern data science.\nThe tidyverse is a coherent collection of modern R packages that solves this problem. It is a coherent system of packages for data manipulation, exploration and visualization that share a common design philosophy. The packages were originally mostly developed by Hadley Wickham, but have been expanded by several contributers and has now developed into a thriving and highly supportive community.\nModern R is the tidyverse, and I strongly recommend that you use the tidyverse when you use R for data science, manipulation and visualisation.\nThere is lots of information about the tidyverse on the web, e.g.\n\nWhat is the tidyverse?\nR for Data Science - an online book by Garrett Grolemund and Hadley Wickham that teaches the concepts of tidy data and shows how R with the tidyverse will help you create tidy data workflows.\n\n\nLoading the tidyverse\nYou can install and use the tidyverse by typing;\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\nThis will download and then import the tidyverse modules. You should see something similar to this printed;\n── Attaching packages ────────────────── tidyverse 1.3.0 ──\n✓ ggplot2 3.3.2     ✓ purrr   0.3.4\n✓ tibble  3.0.3     ✓ dplyr   1.0.2\n✓ tidyr   1.1.2     ✓ forcats 0.5.0\n✓ readr   1.3.1     \n── Conflicts ───────────────────── tidyverse_conflicts() ──\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\nThis shows that the seven core tidyverse modules have been loaded (ggplot2, tibble, tidyr, readr, purrr, dplyr and forcats).\nIt also shows how the modern dplyr::filter and dplyr::lag functions replace the older stats::filter and stats::lag functions.\n\nEXERCISE\nInstall and load the tidyverse. Use the links above for the seven modules to find out exactly what each package provides.\nAnswer",
    "crumbs": [
      "Tidyverse"
    ]
  },
  {
    "objectID": "pages/070-worksheet.html",
    "href": "pages/070-worksheet.html",
    "title": "Worksheet",
    "section": "",
    "text": "This page contains a number of questions and exercises to give you a chance to practise what you have learned this session. You should create a new .R R file for each exercise.\n\n\n\n\n\n\nExercise 1\n\n\n\nThe first exercise is to practise searching the documentation. From the list of modules in the standard library, find one that contains a function to give the current date and time.\nFill in the ... in the snippet below.\nimport ...\n\ntime_now &lt;- ...\n\nprint(time_now.isoformat())\nThe output should be something like the following, but with today’s date and time:\n2048-08-32T10:53:15.062603\n\n\n\n\n\n\n\n\nAnswer 1\n\n\n\n\n\nThe function we can use is datetime.datetime.now(). There is an example in that module as well.\n#| filename: ex1.R\n#| eval: false\n\nimport datetime\n\ntime_now &lt;- datetime.datetime.now()\n\nprint(time_now.isoformat())\n\n\nTerminal/Command Prompt\n\nRScript ex1.R\n\n#| echo: false\nimport datetime\n\ntime_now &lt;- datetime.datetime.now()\n\nprint(time_now.isoformat())\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nWrite a function which can accept a string as an argument and return the first word in that string. To start you off, here’s skeleton of what the function should look like.\ndef first_word(l):\n    ...\n    return ...\nyou should be able to use it like:\nsentence &lt;- \"This is a collection of words\"\nword &lt;- first_word(sentence)\nprint(word)\ngiving the output:\nThis\n\n\n\n\n\n\n\n\nAnswer 2\n\n\n\n\n\n#| filename: ex2.R\n\ndef first_word(l):\n    words &lt;- l.split()\n    the_first_word &lt;- words[0]\n    return the_first_word\n\nsentence &lt;- \"This is a collection of words\"\nword &lt;- first_word(sentence)\nprint(word)\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nWrite a function called count_word_match which accepts three agruments:\n\na string which contains multiple words separated by spaces,\na string which gives the word that you want to count the occurrences of and\na boolean (True or False) which specifies whether the match should be case-sensitive.\n\ndef count_word_match(words, match, case_sensitive):\n    ...\n    return ...\nyou should be able to use it like:\ncount1 &lt;- count_word_match(\"To be or not to be\", \"to\", True)\nprint(count1)\n\ncount2 &lt;- count_word_match(\"To be or not to be\", \"to\", False)\nprint(count2)\ngiving the output:\n1\n2\n\n\n\n\n\n\n\n\nAnswer 3\n\n\n\n\n\n#| filename: ex3.R\n\ndef count_word_match(words, match, case_sensitive):\n    if not case_sensitive:\n        # Make both the words and the match a consistent case\n        words &lt;- words.casefold()\n        match &lt;- match.casefold()\n    \n    word_list &lt;- words.split()\n    \n    count &lt;- 0\n    for word in word_list:\n        if word == match:\n            count += 1\n    \n    return count\n\ncount1 &lt;- count_word_match(\"To be or not to be\", \"to\", True)\nprint(count1)\n\ncount2 &lt;- count_word_match(\"To be or not to be\", \"to\", False)\nprint(count2)\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nFor this exercise, you should write a function which can find references, like [4], in some text.\nIf the function is passed a string like:\n\"I recommend this book [1] but the other book [3] is better. Some people think that this website [10] is the best but I prefer this [7] one.\"\nit should return a list of integers like:\n[1, 3, 10, 7]\nThe function should be called find_references.\n\n\n\n\n\n\n\n\nAnswer 4\n\n\n\n\n\nThis exercise it tricker, but if you make some assumptions about the format of the input, you can make your life easier. For example, you can assume for now that every reference like [4] is surrounded by spaces. This allows str.split() to pull each one out as a “word”. You can also assume that every reference is an integer number.\n#| filename: ex4.R\n\ndef find_references(text):\n    words &lt;- text.split()\n    \n    refs &lt;- []\n    # For each word in the text\n    for word in words:\n        # if it's surrounded by square brackets\n        if word[0] == \"[\" and word[-1] == \"]\":\n            # grab the bit between the square brackets\n            reference &lt;- word[1:-1]\n            # convert it to a number\n            reference_number &lt;- int(reference)\n            refs.append(reference_number)\n    \n    return refs\n\nexample_text &lt;- \"I recommend this book [1] but the other book [3] is better. Some people think that this website [10] is the best but I prefer this [7] one.\"\n\nreferences &lt;- find_references(example_text)\n\nprint(references)\n\n\n\n\n\n\n\n\n\nExercise 5\n\n\n\nTake the function that you wrote in the last exercise and move it into a module called refs. You should then write a test file called test_refs.R containing:\nimport refs\n\ntext &lt;- \"I recommend this book [1] but the other book [3] is better. Some people think that this website [10] is the best but I prefer this [7] one.\"\n\nnumbers &lt;- refs.find_references(text)\n\nexpected &lt;- [1, 3, 10, 7]\nif numbers == expected:\n    print(\"Test passed\")\nelse:\n    print(\"Test failed:\", numbers, \"is not the same as\", expected)\nYou should make sure that the test passes when the test script is run with:\n\n\nTerminal/Command Prompt\n\nRScript test_refs.R\n\n\n\n\n\n\n\n\n\nAnswer 5\n\n\n\n\n\n#| filename: refs.R\n\ndef find_references(text):\n    words &lt;- text.split()\n    \n    refs &lt;- []\n    for word in words:\n        if word[0] == \"[\" and word[-1] == \"]\":\n            reference &lt;- word[1:-1]\n            reference_number &lt;- int(reference)\n            refs.append(reference_number)\n    \n    return refs\n#| filename: test_refs.R\n\nimport refs\n\ntext &lt;- \"I recommend this book [1] but the other book [3] is better. Some people think that this website [10] is the best but I prefer this [7] one.\"\n\nnumbers &lt;- refs.find_references(text)\n\nexpected &lt;- [1, 3, 10, 7]\nif numbers == expected:\n    print(\"Test passed\")\nelse:\n    print(\"Test failed:\", numbers, \"is not the same as\", expected)\n\n\nTerminal/Command Prompt\n\nRScript test_refs.R",
    "crumbs": [
      "Worksheet"
    ]
  },
  {
    "objectID": "pages/990-contributors.html",
    "href": "pages/990-contributors.html",
    "title": "Contributors",
    "section": "",
    "text": "This course has been developed by the Jean Golding Insitute.\nPart of these materials were originally written by Christopher Woods https://chryswoods.com/intermediate_r/.",
    "crumbs": [
      "Contributors"
    ]
  },
  {
    "objectID": "pages/043-tidyverse-exercise.html",
    "href": "pages/043-tidyverse-exercise.html",
    "title": "Tidyverse exercise",
    "section": "",
    "text": "TBD",
    "crumbs": [
      "Tidyverse",
      "Tidyverse exercise"
    ]
  },
  {
    "objectID": "pages/980-summary.html",
    "href": "pages/980-summary.html",
    "title": "Summary",
    "section": "",
    "text": "That’s all we have for this workshop. By now you should have a better understanding of how you can make your code more easily shared and reusable. In this workshow we have covered:\n\nUsing the R libraries and use their functions\nWays of bundling up your code into reusable units with functions\nMaking it possible to share your code with others by moving code into modules\nHow to produce custom errors\nHow to compactly generate lists with list comprehensions",
    "crumbs": [
      "Summary"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to this second course on R programming! This course builds upon Beginning R and delves deeper into working with advanced data structures, write functions, explore modules, and how to handle errors and exceptions. Get ready to take your R skills to the next level!\nFor the purpose of this course we will be using a free tool called JupyterLab which provides you with a local editor and R terminal in your web browser. Setting up instructions can be found here.\n\nIntended learning outcomes\nBy the end of this course, you will:\n\nFeel confident installing and using packages\nKnow how to write functions\nBe familiar with tydiverse ecosystem\nKnow how to read data files\nKnow how to filter and transform data\nKnow how to generate simple plots\n\n\n\nHow to read this documentation\nIn this documentation, any time that we are seeing a small snippet of R code, we’ll see it written in a grey box like the following:\ncat(\"Hello, R\")\nIf the commands are executed by the machine we will see the output of them below enclosed on a vertical purple line:\n\ncat(\"Hello, R!\")\n\nHello, R!\n\n\nBy contrast, you will see larger pices of code as scripts with a given name, e.g. script.R, in a code block with darker header:\n\n\nscript.R\n\nname &lt;- \"Jean Golding\"\ncat(\"Hello,\", name, \"!\")\n\nWe may ask you to run a script using the Command Prompt (Windows) or Terminal (Mac and Linux). We will show you what commands to run and will look like this:\n\n\nTerminal/Command Prompt\n\nRscript script.R\n\nIn some cases we will introduce general programming concepts and structures using pseudocode, a high-level, easy-to-read syntax close to natural language. This should not be confused with R code and cannot be executed on your machine, but it is useful to describe how your code should behave. Here there is an example:\nFOR EACH sample IN my_study\n    IF (sample.value &gt; 100)\n        DO SOMETHING\n    OTHERWISE\n        DO SOMETHING ELSE\nThere are some exercices along this course, and it is important you try to answer them yourself to understand how R works. Exercises are shown in blue boxes followed by a yellow box that contains the answer of each exercise. We recommend you to try to answer each exercise yourself before looking at the solution.\n\n\n\n\n\n\nExercise\n\n\n\nThis is an exercise. You will need to click in the below box to see the answer.\n\n\n\n\n\n\n\n\nAnswer (click to open)\n\n\n\n\n\nThis is the answer.\n\n\n\nLast, we will highlight important points using green boxes like this one:\n\n\n\n\n\n\nKey points\n\n\n\nThese are important concepts and technical notes.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "answers/answer_hello_name.html",
    "href": "answers/answer_hello_name.html",
    "title": "Intermediate R",
    "section": "",
    "text": "To get input from the person running your script, you can use the function input(). And to get the length of your variable you can call len().\n#| filename: hello.R\n#| eval: false\nmy_name &lt;- input(\"Please tell me your name: \")\n\nname_length &lt;- len(my_name)\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")\n#| echo: false\nmy_name &lt;- \"Jean\"\n\nprint(\"Please tell me your name:\", my_name)\n\nname_length &lt;- len(my_name)\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")"
  },
  {
    "objectID": "answers/answer_string_methods.html",
    "href": "answers/answer_string_methods.html",
    "title": "Intermediate R",
    "section": "",
    "text": "You can split any string using the str.split function. By default it splits on spaces:\ns &lt;- \"what is your name\"\ns.split()\n\nJoin a list\nYou can join a list together by using the str.join function. Note that in front of the dot you put the string that you want to join with, and you pass the list you want to join together as an argument.\nl &lt;- [\"a\", \"b\", \"c\"]\n\"-\".join(l)\nl &lt;- [\"a\", \"b\", \"c\"]\n\":\".join(l)\nl &lt;- [\"a\", \"b\", \"c\"]\n\" \".join(l)"
  },
  {
    "objectID": "answers/answer_morse_case.html",
    "href": "answers/answer_morse_case.html",
    "title": "Intermediate R",
    "section": "",
    "text": "The function str.lower gives you back a copy of the string, but all made into lower case.\nIn our situation, the first letter is “S” and so letter.lower() will give us \"s\".\n#| filename: encode.R\n#| output: false\nletter_to_morse &lt;- {\n    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n    'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n    'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n    '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n    '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.', ' ':'/'\n}\n\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\n\nmorse &lt;- []\n\nfor letter in message:\n    letter &lt;- letter.lower()  #  ← We have added this line of code\n    morse_letter &lt;- letter_to_morse[letter]\n    morse.append(morse_letter)\n\nmorse_message &lt;- \" \".join(morse)\n\nprint(f\"Incoming message: {message}\")\nprint(f\"   Morse encoded: {morse_message}\")\n\n\nTerminal/Command Prompt\n\nRScript encode.R\n\n#| echo: false\nletter_to_morse &lt;- {\n    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n    'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n    'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n    '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n    '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.', ' ':'/'\n}\n\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\n\nmorse &lt;- []\n\nfor letter in message:\n    letter &lt;- letter.lower()  #  ← We have added this line of code\n    morse_letter &lt;- letter_to_morse[letter]\n    morse.append(morse_letter)\n\nmorse_message &lt;- \" \".join(morse)\n\nprint(f\"Incoming message: {message}\")\nprint(f\"   Morse encoded: {morse_message}\")"
  },
  {
    "objectID": "pages/030-functions.html",
    "href": "pages/030-functions.html",
    "title": "Functions",
    "section": "",
    "text": "You are likely already comfortable with calling functions such as:\n\nfree functions like print() and range()\nfunctions on objects (also called methods) like my_list.append() and my_str.split()\n\nIn this section we’re going to explore other functions and methods available as part of R’s core capabilities and in other modules. An important technical resource you probably will come across often is The R Standard Library.\n\nBuilt-in functions\nR comes with a bunch of functionality that you can use without having to explicitly enable anything. This includes things like integers, strings, lists, print()ing, file open()ing etc.\nFirst, lets have a peek at the built-in functions. There is a page describing these under the “Library Reference”, in a page called Built-in Functions. There we find the documentation for many of the functions we’ve already been using, for example print() and max().\nIt is worth, over time, becoming familiar with the various functions that are available. Some are quite useful for everyday work and some are more niche.\n\n\n\n\n\n\nExercise\n\n\n\nCopy the following code into a new script hello.R:\nmy_name &lt;- ...\n\nname_length &lt;- ...\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")\nReplace the first ... with a call to a built-in function which will read input from the person running the script. Replace the second ... with a call to a function which will give the length of the string my_name. When executed, the script should print out:\nPlease tell me your name: Jean\nHello Jean! Your name is 4 characters long\nIf you need it, you can search through the built-in functions page to find the appropriate functions.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nTo get input from the person running your script, you can use the function input(). And to get the length of your variable you can call len().\n#| filename: hello.R\n#| eval: false\nmy_name &lt;- input(\"Please tell me your name: \")\n\nname_length &lt;- len(my_name)\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")\n#| echo: false\nmy_name &lt;- \"Jean\"\n\nprint(\"Please tell me your name:\", my_name)\n\nname_length &lt;- len(my_name)\n\nprint(f\"Hello {my_name}! Your name is {name_length} characters long\")\n\n\n\n\n\nMethods for built-in data types\nR has a bunch of built-in data types, the details of them all are on the page called Built-in Types. That is the place to go to check what you can do with a str, an int, a list or a dict. There’s also a few other built-in types you might want to look into in the future such as complex, set and tuple.\nThese types being built-in means that you don’t need to explicitly enable their use and most have core-language syntax to create them.\nFor example, the code\nanimal &lt;- \"horse\"\ncreates a variable called animal from the string literal \"horse\" which is of the type str. This data type is built into the language and so the functionality that it has is documented on built-in type str.\nThis means that when we do:\nanimal.capitalize()\nit is looking at the data type of the variable animal, seeing that it is a str and then using the capitalize function that’s available for that type to do the work.\n\n\n\n\n\n\nExercise\n\n\n\nHave a look at the documentation page for the functions that you can call on strings.\nExperiment with one or two and see if you can understand the documentation. Start by trying to answer the following:\n\nGiven a string like s &lt;- \"what is your name\", find a function which can split s into a list like [\"what\", \"is\", \"your\", \"name\"]\nGiven a list like [\"a\", \"b\", \"c\"], find a function which can join it together into a string like \"a-b-c\"\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYou can split any string using the str.split function. By default it splits on spaces:\ns &lt;- \"what is your name\"\ns.split()\n\nJoin a list\nYou can join a list together by using the str.join function. Note that in front of the dot you put the string that you want to join with, and you pass the list you want to join together as an argument.\nl &lt;- [\"a\", \"b\", \"c\"]\n\"-\".join(l)\nl &lt;- [\"a\", \"b\", \"c\"]\n\":\".join(l)\nl &lt;- [\"a\", \"b\", \"c\"]\n\" \".join(l)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nChange the message in encode.R to use both upper and lower case letters:\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\nWhen you now run the script with RScript encode.R you will find that it gives you a KeyError. This is because it is looking for an upper case “S” in the dictionary letter_to_morse and not finding one (dictionary keys are case-sensitive).\nRead through the documentation for the string methods to find one that might help convert the letter you have into one that matches the keys in the dictionary. You should be able to add a single line of code in the loop straight after for letter in message:.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe function str.lower gives you back a copy of the string, but all made into lower case.\nIn our situation, the first letter is “S” and so letter.lower() will give us \"s\".\n#| filename: encode.R\n#| output: false\nletter_to_morse &lt;- {\n    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n    'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n    'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n    '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n    '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.', ' ':'/'\n}\n\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\n\nmorse &lt;- []\n\nfor letter in message:\n    letter &lt;- letter.lower()  #  ← We have added this line of code\n    morse_letter &lt;- letter_to_morse[letter]\n    morse.append(morse_letter)\n\nmorse_message &lt;- \" \".join(morse)\n\nprint(f\"Incoming message: {message}\")\nprint(f\"   Morse encoded: {morse_message}\")\n\n\nTerminal/Command Prompt\n\nRScript encode.R\n\n#| echo: false\nletter_to_morse &lt;- {\n    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n    'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n    'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n    '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n    '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.', ' ':'/'\n}\n\nmessage &lt;- \"SOS We have hit an iceberg and need help quickly\"\n\nmorse &lt;- []\n\nfor letter in message:\n    letter &lt;- letter.lower()  #  ← We have added this line of code\n    morse_letter &lt;- letter_to_morse[letter]\n    morse.append(morse_letter)\n\nmorse_message &lt;- \" \".join(morse)\n\nprint(f\"Incoming message: {message}\")\nprint(f\"   Morse encoded: {morse_message}\")",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "pages/032-writing-functions.html",
    "href": "pages/032-writing-functions.html",
    "title": "Writing functions",
    "section": "",
    "text": "Functions provide a way of packaging code into reusable and easy-to-use components. We saw plenty of examples of functions in the last chapter, e.g. print() wraps up all the logic about exactly how to print things, all you need to do is pass in some arguments and it handles the rest. Likewise with math.sqrt(), you don’t need to understand the algorithm it uses, simply what it needs you to pass it, and what it returns back to you.\nYou can also bundle up your own logic into functions, allowing you to avoid repeating yourself and make your code easier to read. To explain how they work, lets imagine we are writing some code to help us with baking recipes. Often you will need to convert between different units, for example from ounces to grams. Create a new script convert.R with the below code and run it.\n\nWriting your own functions\nYou can write your own functions in R! For example, let’s try to write a function that calculates the mean average of a list of numbers.\nAs input, the function will take a list of numbers. It should output a number which is the mean of those numbers.\nThere are many ways this function could be written. Here is a possible solution;\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n}\nWe can then use this function, to, e.g. calculate the average height of a group of people, by typing;\nperson_heights = c(1.62, 1.80, 1.56, 1.73, 1.91)\n\naverage_height &lt;- calculate_mean(person_heights)\n\ncat(sprintf(\"The average height is %.2f m\\n\", average_height))\nRunning this would print;\nThe average height is 1.72 m\n\n\nScaffolding\nTo explain how this worked, we need to look at how this function was defined. There is some scaffolding that is common to all functions. First, we define the function name. In R, this is a variable that holds the code of the function. We define this variable and assign data to it in the same way as if this was assigning a number to a numeric variable, or a string to a string variable, namely using the syntax variable &lt;- value:\n   Variable    assigned  value \n      ↓           ↓      ↓\ncalculate_average &lt;- function(...\nNext, we have the keyword function, that says that this is some data that is of type function. This means that the data will contain code. The arguments to function are the arguments you would like to use as input for your new function;\n                     keyword  arguments\n                        ↓        ↓\ncalculate_average &lt;- function(values) {\nNext, you need the body of the function. This body is the lines of code that will be run when your function is called. Just like with for loops or if statements, the body of code is contained within curly brackets\n                                  Open curly brackets\n                                      ↓\ncalculate_average &lt;- function(values) {\n    # body of the function is the\n    # lines of code within the curly brackets\n}\n↑\nClose curly brackets\nThe input(s) for the function is/are the argument(s) that are passed to function, in this case, values. Our code will loop through all of the values in values to calculate the mean average. Once we have finished, we reach the final part of the function, which is return. This is used to return the output of the function back to the caller.\n                           Input(s)\n                             ↓\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n        ↑\n     Return output\n}\nFinally, when we call the function, the arguments that pass to the function are used as the input. The output is then returned and assigned to the result variable. So, in this case;\n                Call function      with input(s)\n                        ↓             ↓  \naverage_height &lt;- calculate_mean(person_heights)\n     ↑         ↑\n  Output     assigned\ncalculate_mean is called with person_heights. The data referred to by person_heights is passed to calculate_mean and in this function is referred to as values. This data is looped over, the mean average calculated, resulting in an output that is returned at the end of the function, and assigned to the variable average_height.\n\nEXERCISE\nWrite a function, called calculate_max, that returns the largest value. Use this to find the largest height in the list of heights above.\nHint - start by using a variable called max_value and setting that equal to NA. Then use if (is.na(max_value) || value &gt; max_value) to test whether a value in values is greater. The || means “or”\nAnswer\n\n## Errors\nYour function works well, but what would happen if the wrong arguments were passed? What should we do if someone did this?\nresult &lt;- calculate_mean(c(\"cat\", \"dog\", \"horse\"))\nIf you run this now, you will see that R prints an error;\nError in total + value : non-numeric argument to binary operator\nThis isn’t very descriptive of helpful. You can control how R will behave in an error condition by using stop or warning.\nYou use stop if you want to stop the function from continuing, and to print an error message for the user. For example, we could use is.numeric to check if all of the values are numeric. If not, then we could stop;\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         if (!is.numeric(value)){\n             stop(\"Cannot calculate average of non-numeric values\")\n         }\n         total &lt;- total + value\n         count &lt;- count + 1\n     }\n     return(total / count)\n}\n(note that ! means “not”)\nNow running;\nresult &lt;- calculate_mean(c(\"cat\", \"dog\", \"horse\"))\ngives the more useful error message;\nError in calculate_mean(c(\"cat\", \"dog\", \"horse\")) : \n  Cannot calculate average of non-numeric values\nHowever, what if instead of stopping, we want to calculate the average of any numeric values, and just warn the user if non-numeric values are passed? We can do this using the warning function, e.g.\ncalculate_mean &lt;- function(values){\n     total &lt;- 0.0\n     count &lt;- 0\n     for (value in values){\n         number &lt;- as.numeric(value)\n\n         if (!is.na(number)){\n             total &lt;- total + number\n             count &lt;- count + 1\n         } else {\n             warning(\"Skipping '\", value, \n                     \"' as it is not numeric\")\n         }\n     }\n     return(total / count)\n}\nIn this case, we try to convert the value into a number using the as.numeric function. If this fails, it will return NA. We then test for NA using the is.na function, printing a warning that we are skipping this value if it isn’t a number.\n\nEXERCISE\nAdd error handling to your calculate_max function so that it warns when non-numeric values are skipped, and stops when there is no maximum value (i.e. because there are no numeric values passed).\nAnswer",
    "crumbs": [
      "Functions",
      "Writing functions"
    ]
  },
  {
    "objectID": "pages/042-tidyverse-pipe.html",
    "href": "pages/042-tidyverse-pipe.html",
    "title": "Pipes %>%",
    "section": "",
    "text": "The tidyverse makes heavy use of the R concept of forward pipes. Forward pipes, represented via %&gt;%, are provided by the magrittr package, which should be automatically loaded by the tidyverse.\n(if not, you can load it via load.packages(\"magrittr\"))\nA forward pipe forwards the variable on the left into the first argument to the function on the right, e.g.\n\"kitten\" %&gt;% print()\nwill forward the string “kitten” so that it is the first argument to the function print. Hence this is exactly identical to\nprint(\"kitten\")\nand so\n[1] \"kitten\"\nis printed.\nYou may ask why this is useful? It is useful because it enables you to chain together a lot of functions. For example, the tidyverse dply package provides the function filter, for filtering data.\nSo;\ncats %&gt;% filter(Sex==\"F\")\n# A tibble: 47 x 3\n   Sex   BodyWeight HeartWeight\n   &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1 F            2           7  \n 2 F            2           7.4\n 3 F            2           9.5\n 4 F            2.1         7.2\n 5 F            2.1         7.3\n 6 F            2.1         7.6\n 7 F            2.1         8.1\n 8 F            2.1         8.2\n 9 F            2.1         8.3\n10 F            2.1         8.5\n# … with 37 more rows\nhas filtered the cats data set from the last page to return a tibble that contains data only for female cats.\nThis was identical to typing;\nfilter(cats, Sex==\"F\")\nThe power comes that we can now chain filters, e.g.\ncats %&gt;% filter(Sex==\"F\") %&gt;% filter(BodyWeight &gt; 2.5)\n# A tibble: 11 x 3\n   Sex   BodyWeight HeartWeight\n   &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1 F            2.6         8.7\n 2 F            2.6        10.1\n 3 F            2.6        10.1\n 4 F            2.7         8.5\n 5 F            2.7        10.2\n 6 F            2.7        10.8\n 7 F            2.9         9.9\n 8 F            2.9        10.1\n 9 F            2.9        10.1\n10 F            3          10.6\n11 F            3          13  \nWe can then use the dplyr summarise function to call calculate_mean on a specified row of this filtered data, e.g.\ncats %&gt;% \n    filter(Sex==\"F\") %&gt;% \n    filter(BodyWeight&gt;2.5) %&gt;% \n    summarise(mean=calculate_mean(HeartWeight))\nwill output\n# A tibble: 1 x 1\n   mean\n  &lt;dbl&gt;\n1  10.2\nas the mean average of the heart weight in grams of female cats whose body weight is greater than 2.5 kg.\nNote how we have split this over multiple lines, putting the forward pipe %&gt;% at the end so that it is clear that the line continues (use Shift+Enter to start a new line without running the command in the R Console).\nTo save this to a variable, we would use the assign &lt;- as normal, hence the full code should be;\naverage_heart_weight &lt;- cats %&gt;%\n    filter(Sex==\"F\") %&gt;%\n    filter(BodyWeight&gt;2.5) %&gt;%\n    summarise(mean=calculate_mean(HeartWeight))\nYes, this is a very dense bit of code. This is typical for R. You will often see very dense blocks of code that use forward pipes to push data through several functions, resulting in a final output result. As you can see, it is important that you name your variables, data, columns and functions clearly, so that it is easier for future readers of your code to understand what is going on.\nFinally, note that average_heart_weight is a 1x1 tibble. You can extract the actual numeric value by typing as.numeric(average_heart_weight).\n\nEXERCISE\nCalculate the average heart weight of male cats whose body weight is greater than or equal to 3.0 kg.\nAnswer\nCalculate the maximum body weight of both the male cat and the female cat that has a heart weight of less than or equal to 9 grams.\nAnswer\nLook back at the vignette you found when searching for the Pearson’s product-moment correlation. How much more of this vignette do you now understand? Have a go at installing packages that you don’t recognise, and using ? in RStudio to get help on the functions that are new to you.",
    "crumbs": [
      "Tidyverse",
      "Pipes %>%"
    ]
  },
  {
    "objectID": "pages/041-tidyverse-tibbles.html",
    "href": "pages/041-tidyverse-tibbles.html",
    "title": "Tibbles",
    "section": "",
    "text": "Loading the tidyverse\nlibrary(tidyverse)\n\n\nTibbles and readr\nWe will learn and use the tidyverse in much more depth in future workshops. For today, we will look at tibble. A tibble is the modern tidyverse version of a data.frame. A tibble is a data.frame, and so can be used in the same way. But it comes with more powerful features and removes inconsistent and confusing behaviour.\nIn the same way, readr provides modern tidyverse replacements for R’s standard reading functions. readr provides read_csv, which is a better way of reading csv files than R’s standard read.csv.\nLet’s now use the tidyverse to read_csv the cats data set into a tibble.\ncats &lt;- read_csv(\"https://chryswoods.com/intermediate_r/data/cats.csv\")\nThe first thing you will notice is that the tidyverse has printed out some useful information;\nParsed with column specification:\ncols(\n  Sex = col_character(),\n  BodyWeight = col_double(),\n  HeartWeight = col_double()\n)\nThis is telling you that read_csv found three columns; Sex, which is treated as a columns of strings (characters), and BodyWeight and HeartWeight, which are both treated as columns of floating point numbers (doubles).\nNext, if you type cats and press return…\ncats\n# A tibble: 144 x 3\n   Sex   BodyWeight HeartWeight\n   &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1 F            2           7  \n 2 F            2           7.4\n 3 F            2           9.5\n 4 F            2.1         7.2\n 5 F            2.1         7.3\n 6 F            2.1         7.6\n 7 F            2.1         8.1\n 8 F            2.1         8.2\n 9 F            2.1         8.3\n10 F            2.1         8.5\n# … with 134 more rows\nYou can see that the tibble summarises itself to the screen. This makes it much easier to quickly look at some data without it overflowing your console.\nAs a tibble is a data.frame, you can use the same methods of accessing data, e.g.\ncats$Bodyweight\n[1] 2.0 2.0 2.0 2.1 2.1 2.1 2.1 2.1 2.1 2.1 2.1 2.1 2.2\n [14] 2.2 2.2 2.2 2.2 2.2 2.3 2.3 2.3 2.3 2.3 2.3 2.3 2.3\n [27] 2.3 2.3 2.3 2.3 2.4 2.4 2.4 2.4 2.5 2.5 2.6 2.6 2.6\n [40] 2.7 2.7 2.7 2.9 2.9 2.9 3.0 3.0 2.0 2.0 2.1 2.2 2.2\n [53] 2.2 2.2 2.2 2.2 2.2 2.2 2.3 2.4 2.4 2.4 2.4 2.4 2.5\n [66] 2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.6 2.6 2.6 2.6 2.6 2.6\n [79] 2.7 2.7 2.7 2.7 2.7 2.7 2.7 2.7 2.7 2.8 2.8 2.8 2.8\n [92] 2.8 2.8 2.8 2.9 2.9 2.9 2.9 2.9 3.0 3.0 3.0 3.0 3.0\n[105] 3.0 3.0 3.0 3.0 3.1 3.1 3.1 3.1 3.1 3.1 3.2 3.2 3.2\n[118] 3.2 3.2 3.2 3.3 3.3 3.3 3.3 3.3 3.4 3.4 3.4 3.4 3.4\n[131] 3.5 3.5 3.5 3.5 3.5 3.6 3.6 3.6 3.6 3.7 3.8 3.8 3.9\n[144] 3.9\ncats[1,]\n# A tibble: 1 x 3\n  Sex   BodyWeight HeartWeight\n  &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n1 F              2           7\netc.\n\nEXERCISE\nLoad the cats data set into a tibble using read_csv. Use the calculate_mean and calculate_max functions from before to calculate the mean and max body weight and heart weight of the cats.\nWhat are the units for the weights? A description of the data set can be found here.\nAnswer",
    "crumbs": [
      "Tidyverse",
      "Tibbles"
    ]
  },
  {
    "objectID": "pages/010-workspace-setup.html",
    "href": "pages/010-workspace-setup.html",
    "title": "Workspace setup",
    "section": "",
    "text": "There are lots of different ways to run R code and many tools to help you write it. You don’t require any special tools to create an R script, a simple text editor like Notepad on Windows is sufficient. More advanced tools include IDEs like RStudio or Visual Studio Code.\nFor this workshop we will be keeping things as simple as possible in order to allow us to focus on the topics we’re learning without having to learn too many extra tools along the way.\nFor the purpose of this course we will be using a free tool called RStudio which provides you with an integrated enviroment where you can write and run R code. The easiest way to get access to R and RStudio is first downloading and installing the latest R version from https://cran.rstudio.com/, and after downloading and installing RStudio from https://posit.co/download/rstudio-desktop/. You may need administrator access to install R and RStudio on your computer. Both tools are freely available for Windows, MacOS and Linux.\n\n\n\n\n\n\nInstallation on University managed computers\n\n\n\nIf you are using a University of Bristol computer, you will find R and RStudio in Company Portal.\n\n\nOnce both are installed, you can open RStudio and will look something like this:\n\nThe way that we will be setting up the space is to have a text editor on the top-left side of the screen and the R console on the bottom-left side. We’ll use the editor to write our code and the console to run it. On the right side we can keep other tabs open.\n\nWorking directory\nSetting up a working directory helps organize your project files and ensures that your code can find any necessary resources and dependencies. We will revisit this concept later on, but for now be mindful that the space where you save your scripts has to be the same than the working directory where R console and/or your Command Prompt/Terminal are working,\nIn R Console you can print the current working directory it with\ngetwd()\n\n\n[1] \"/Users/ab12345\"\n\n\nAlternatively, if you are using the Command Prompt (Windows) you can check your current directory with\n\n\nCommand Prompt\n\ncd\n\nOr if you are using a Terminal (MacOS and Linux) you can check your current directory with\n\n\nTerminal\n\npwd\n\nWe’re now ready to get started!",
    "crumbs": [
      "Workspace setup"
    ]
  },
  {
    "objectID": "pages/022-loading-packages.html",
    "href": "pages/022-loading-packages.html",
    "title": "Loading packages",
    "section": "",
    "text": "Using a package\nYou can use a package in your script via the library command. To use stringr you should type;\nlibrary(stringr)\ninto the console. When you press return, nothing should happen. If you see output similar to;\nError in library(stringr) : there is no package called ‘stringr’\nthen this means that stringr is not installed properly.\nTo get help on a package type ? before its name, e.g.\n?stringr\nAll of the functions in stringr start with str_ and take a string (or vector/list of strings) as the first argument.\nKey functions are;\n\nstr_c : Modern replacement for cat\nstr_length : Count the number of characters in a string\nstr_sub : Extract substrings\nstr_trim : Remove trailing and leading whitespace\nstr_pad : Pad a string\nstr_wrap : Wrap a string into a paragraph\n\n\nEXERCISE\nUse ? to learn about the above stringr functions and have a play printing different strings to the console.\nAnswer\n\n\n\nCRAN\nThe power of R comes from its great wealth of excellent packages. These packages are managed in a central repository called CRAN (the Comprehensive R Archive Network). There are very strict protocols to follow to publish a package in CRAN, which includes an external review stage. As such, publishing an R package is a lot like publishing a paper, and so R packages on CRAN are mostly of a high standard, and come complete with documentation and tests. You can get an idea of what is needed to publish a package on CRAN by reading R Packages by Hadley Wickham and Jennifer Bryan. This excellent online book provides complete detail of how to write and publish an R package.\nA good way to find the package you want is to use an R search service, such as rseek. You can search for individual package names, or even the kind of thing you want to do. As most R packages come with vignettes (web pages that show examples of how to use the package) this means you can quickly find both the package that achieves your goal, plus really clear documentation and examples.\n\nEXERCISE\nUse rseek to look for packages that help you calculate Pearson’s product-moment correlation. Limit the search to vignettes. Can you find a vignette that shows you how to do this? Do not worry that the R in the vignette is more advanced than you’ve seen so far - it won’t be long before it will make sense ;-)\nAnswer",
    "crumbs": [
      "Packages",
      "Loading packages"
    ]
  },
  {
    "objectID": "pages/021-install-packages.html",
    "href": "pages/021-install-packages.html",
    "title": "Installing packages",
    "section": "",
    "text": "For example, the Stringr package provides a set of modern functions for manipulating and formatting strings.\nTo use Stringr, we first need to install the package. You install packages in R using install.packages, e.g. type into your console;\ninstall.packages(\"stringr\")\nand hit return. If your user account has permission to install packages then you should see something like;\ntrying URL 'https://cran.rstudio.com/bin/macosx/contrib/4.0/stringr_1.4.0.tgz'\nContent type 'application/x-gzip' length 210650 bytes (205 KB)\n==================================================\ndownloaded 205 KB\n\n\nThe downloaded binary packages are in\n    /var/folders/vg/lyxsq9391fxfm64hfdfr88f40000gq/T//Rtmp57uUY0/downloaded_packages\nNotice that this will automatically get the right package for your operating system (in my case macosx). Also note that you only have to do this once, as once installed, this package is available for everyone.\n\nUpdating packages\nR’s strength is its packages, and what makes this easier is that package management is handled directly within the language.\nYou can update a package by running install.packages again, e.g. to update stringr to the newest version, just type;\ninstall.packages(\"stringr\")\nYou can get a list of all installed packages via installed.packages(), e.g.\ninstalled.packages()\nYou can get a list of all packages for which new versions are available using old.packages(), e.g.\nold.packages()\nYou can update all packages for which updates are available using update.packages(). Set ask=FALSE to update everything without prompting, e.g.\nupdate.packages(ask=FALSE)\nNote that updating all of your packages could take a while if you haven’t done it recently…",
    "crumbs": [
      "Packages",
      "Installing packages"
    ]
  }
]